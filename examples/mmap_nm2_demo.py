import sys
sys.path.insert(0, './../src/')
import time
from memmap_nm2 import MMRST
from packet_handler import TCPhandler

tcp = TCPhandler()
MM_CONF = MMRST.copy()

# SYS RESET
tcp.writeSysReg(0xFFA0, 0, 1)
data = tcp.getSystemReadBack(200)
print(f'Data: {data}')
tcp.writeSysReg(0xFFA0, 1, 1)
data = tcp.getSystemReadBack(200)
print(f'Data: {data}')

# SYS CLOCK ENABLE
tcp.writeSysReg(0x0C01, 4, 1)


# ------------------- Changes to SPI_REG0/1 from default (see tb_product.init_asic) -------------------     
MM_CONF.fields['seq_halt'].set_value(1)              # Halt sequencr    
MM_CONF.fields['seq_reset'].set_value(0)             # Release sequencer reset   
MM_CONF.fields['sys_clk_enable'].set_value(1)        # Enable sys_clk     
MM_CONF.fields['pll_enable'].set_value(1)            # Enable internal PLL    
MM_CONF.fields['sysclk_dly'].set_value(2)            # Set sys_clk delay to 3 tx_clk cycles after adc_clk   
MM_CONF.fields['clk_div_mode'].set_value(2)          # Set sys_clk/adc_clk source div20(tx_clk)

# ------------------- Clock setup -------------------     
MM_CONF.fields['tx_clk_en'].set_value(1)             # Enable tx_clk    
MM_CONF.fields['vadc_clk_en'].set_value(1)           # Enable vadc_clk     

# ------------------- TX setup -------------------
# ---- Various ----
MM_CONF.fields['tx_learn'].set_value(0)              # Send LEARN symbol when the TX is in IDLE         
MM_CONF.fields['tx_eof'].set_value(0)                # Send EOF at the end of a frame/stream
MM_CONF.fields['tx_crc'].set_value(0)                # Send CRC of previous frame/stream in next frame/stream
MM_CONF.fields['tx_vadc_addsync'].set_value(0)       # Embed line and frame sync in ADC data
MM_CONF.fields['tx_aadc_addside'].set_value(0)       # Embed AUX input select in ADC data
MM_CONF.fields['tx_clkpad_en_n'].set_value(0)        # Enable TX clock pad (active low)

# ---- LVDS bias ----
MM_CONF.fields['biasmodule_sel_vref_ext'].set_value(0)   # Use internal BGR as LVDS reference 
MM_CONF.fields['biasmodule_enable_n'].set_value(0)       # Enable LVDS bias (active low)

# ---- Protocol ----
MM_CONF.fields['tx_pattern_sof'].set_value(124)      # Control symbol for SOF K28.3
MM_CONF.fields['tx_pattern_eof'].set_value(92)       # Control symbol for EOF K28.2
MM_CONF.fields['tx_pattern_skip'].set_value(188)     # Control symbol for SKIP K28.5
MM_CONF.fields['tx_pattern_learn'].set_value(60)     # Control symbol for LEARN K28.1

# ---- Frame type ----
MM_CONF.fields['tx0_ft'].set_value(2)                # 0 = SSF, 1 = MSF, 2 = MSS, 3 = MSS ADC 
MM_CONF.fields['tx1_ft'].set_value(2)                #   SSF : Single Source Frame
MM_CONF.fields['tx2_ft'].set_value(2)                #   MSF : Multi Source Frame
MM_CONF.fields['tx3_ft'].set_value(2)                #   MSS : Multi Source Stream
MM_CONF.fields['tx4_ft'].set_value(2)                #   MSS ADC : Multi Source Stream ADC
MM_CONF.fields['tx5_ft'].set_value(2)                 
MM_CONF.fields['tx6_ft'].set_value(2)                 
MM_CONF.fields['tx7_ft'].set_value(2)                 
MM_CONF.fields['tx8_ft'].set_value(1)                 


# ------------------- ACQ setup -------------------
# ---- Control ----
MM_CONF.fields['acq_vadc_mode'].set_value(0)         # 0=Immediate, 1=withValid, 2=Frame, 3=<Not working>
MM_CONF.fields['acq_vadc_source'].set_value(2)       # 0=Ext, 1=BusReg, 2=DOR, 3=Seq
MM_CONF.fields['acq_vadc_delay_adcacq'].set_value(0) # Delay the ACQ to use original ACQ as Row-Clock
MM_CONF.fields['acq_vadc_count'].set_value(0)        # Enable counting columns, lines, frames
MM_CONF.fields['acq_vadc_valid_active'].set_value(1) # Active valid polarity ( valid comes from sensor )
MM_CONF.fields['acq_vadc_valid_gate'].set_value(1)   # Gate ACQ with Valid
MM_CONF.fields['acq_vadc_pass_valid'].set_value(0)   # Pass Valid to SideChannel ( not generate Syncs )
MM_CONF.fields['acq_vadc_gensync'].set_value(0)      # Sync signals are generated by internal FSM
MM_CONF.fields['acq_aadc_mode'].set_value(0)         # 0=Immediate, 1=<Not used>, 2=Loop, 3=<Not working>
MM_CONF.fields['acq_aadc_source'].set_value(2)       # 0=Ext, 1=BusReg, 2=DOR, 3=Seq
MM_CONF.fields['acq_aadc_count'].set_value(0)        # Enable counting loops
MM_CONF.fields['acq_din_mode'].set_value(0)          # 0=Immediate, 1=<Not used>, 2=Loop, 3=<Not working>
MM_CONF.fields['acq_din_source'].set_value(2)        # 0=Ext, 1=BusReg, 2=DOR, 3=Seq

# ---- Enable ----
MM_CONF.fields['acq_vadc_en'].set_value(int("1111111111111111",2))       # Enable VADC ACQ for Video Channel 15(MSB) ... 0(LSB)
MM_CONF.fields['acq_vadc_vec_en'].set_value(int("00000001",2))           # DOR-Enable-Mask. Which DOR can trigger the ACQ start
MM_CONF.fields['acq_aadc_en'].set_value(0)                               # Enable AADC ACQ for AADC
MM_CONF.fields['acq_aadc_vec_en'].set_value(int("00000001",2))           # DOR-Enable-Mask for starting ACQ AADC
MM_CONF.fields['acq_din_en'].set_value(0)                                # Enable DIN ACQ for DIN
MM_CONF.fields['acq_din_vec_en'].set_value(int("00000000",2))            # DOR-Enable-Mask for starting ACQ DIN

# ---- Columns, lines, frames, loops ----
MM_CONF.fields['acq_vadc_columns'].set_value(1920)        # Columns to read out
MM_CONF.fields['acq_vadc_lines'].set_value(1080)          # Lines to read out
MM_CONF.fields['acq_vadc_frames'].set_value(10)           # Frames to read out
MM_CONF.fields['acq_vadc_delay'].set_value(0)             # Start delay, between lines and frames delay.
MM_CONF.fields['acq_vadc_period'].set_value(0)            # Period between ACQ pulses.

MM_CONF.fields['acq_aadc_loops'].set_value(1024)     # Loop to read out
MM_CONF.fields['acq_aadc_delay'].set_value(0)        # Start delay, between lines and frames delay.
MM_CONF.fields['acq_aadc_period'].set_value(0)       # Start delay, between lines and frames delay.

MM_CONF.fields['acq_din_loops'].set_value(1024)      # Loop to read out
MM_CONF.fields['acq_din_delay'].set_value(0)         # Start delay, between lines and frames delay.
MM_CONF.fields['acq_din_period'].set_value(0)        # Start delay, between lines and frames delay.

# ------------------- ADC input and mode setup -------------------
MM_CONF.fields['vadc_srefp_sel'].set_value(0)        # 0=SREFP, 1=SREFN, 2=VCM, 3=AVSS 
MM_CONF.fields['vadc_srefn_sel'].set_value(0)        # 0=SREFN, 1=SREFP, 2=VCM, 3=AVSS
MM_CONF.fields['aadc_srefp_sel'].set_value(0)        # 0=SREFP, 1=SREFN, 2=VCM, 3=AVSS
MM_CONF.fields['aadc_srefn_sel'].set_value(0)        # 0=SREFN, 1=SREFP, 2=VCM, 3=AVSS
MM_CONF.fields['aadc_input_sel'].set_value(0)        # 0=AUX0,  1=AUX1,  2=AUX2,3=Internal Temp Sensor
MM_CONF.fields['aadc_inm_sel'].set_value(1)          # 0=AVSS,  1=AUX_INM 
MM_CONF.fields['vadc_acquire_mode'].set_value(0)     # 0=Always on, 1=At acquire, 2=? , 3=none
MM_CONF.fields['aadc_acquire_mode'].set_value(0)     # 0=Always on, 1=At acquire, 2=? , 3=none
MM_CONF.fields['vadc_preamp_gain'].set_value(0)      # VADC gain #0=x1, 1=x1.14, 2=x1.33, 3=x1.6, 4=x2, 5=x2.67, 6=x4, 7=x8
MM_CONF.fields['aadc_preamp_gain'].set_value(0)      # AADC gain #0=x1, 1=x1.14, 2=x1.33, 3=x1.6, 4=x2, 5=x2.67, 6=x4, 7=x8

# ------------------- Reference setup -------------------
MM_CONF.fields['bgr_trimdac'].set_value(31)
MM_CONF.fields['bgr_enable'].set_value(1)
MM_CONF.fields['bgr_buf_enable'].set_value(1)
MM_CONF.fields['adc_vref_cm_buf_drive'].set_value(0)
MM_CONF.fields['adc_vref_dac'].set_value(38)
MM_CONF.fields['adc_vref_cm_dac'].set_value(30)
MM_CONF.fields['vadc_srefp_dac'].set_value(198)    
MM_CONF.fields['vadc_srefn_dac'].set_value(198)          
MM_CONF.fields['aadc_srefp_dac'].set_value(198)   
MM_CONF.fields['aadc_srefn_dac'].set_value(198)  
MM_CONF.fields['vadc_srefp_enable'].set_value(1) 
MM_CONF.fields['vadc_srefn_enable'].set_value(1)
MM_CONF.fields['vadc_srefp_drive'].set_value(0) 
MM_CONF.fields['vadc_srefn_drive'].set_value(0)
MM_CONF.fields['aadc_srefp_enable'].set_value(1) 
MM_CONF.fields['aadc_srefn_enable'].set_value(1)
MM_CONF.fields['aadc_srefp_drive'].set_value(0) 
MM_CONF.fields['aadc_srefn_drive'].set_value(0)
MM_CONF.fields['idc_dac'].set_value(63)
MM_CONF.fields['iptat_dac'].set_value(32)
MM_CONF.fields['idc_3b5dac'].set_value(63)
MM_CONF.fields['iptat_3b5dac'].set_value(32)
MM_CONF.fields['idc_2b5dac'].set_value(63)
MM_CONF.fields['iptat_2b5dac'].set_value(32)

# ------------------- ADC and TX select + TX sources  -------------------

vadc_enable_val = "0000000000000000"                    # VADC Channel 15(MSB) ... 0(LSB) enable vector
start_ch = 7
end_ch = 7
rx_ch = 7

vadc_select = 1
all_vadc = True

if all_vadc == True: 
    vadc_enable_val = "1111111111111111"                
    start_ch = 0
    end_ch = 7
    rx_ch = int(vadc_select/2)
    
else:
    vadc_enable_val = vadc_enable_val[0:15-vadc_select] + '1' + vadc_enable_val[15-vadc_select+1:]
    start_ch = int(vadc_select/2)
    end_ch = int(vadc_select/2)        
    rx_ch = int(vadc_select/2)


MM_CONF.fields['vadc_enable'].set_value(int(vadc_enable_val,2))   

tx_ch7_0_en = "".join((str(int(vadc_enable_val[0]) or int(vadc_enable_val[1])),
                    str(int(vadc_enable_val[2]) or int(vadc_enable_val[3])),
                    str(int(vadc_enable_val[4]) or int(vadc_enable_val[5])),
                    str(int(vadc_enable_val[6]) or int(vadc_enable_val[7])),
                    str(int(vadc_enable_val[8]) or int(vadc_enable_val[9])),
                    str(int(vadc_enable_val[10]) or int(vadc_enable_val[11])),
                    str(int(vadc_enable_val[12]) or int(vadc_enable_val[13])),
                    str(int(vadc_enable_val[14]) or int(vadc_enable_val[15]))))
        
MM_CONF.fields['tx_ch7_0_en'].set_value(int(tx_ch7_0_en,2))

# ---- TX sources ----
tx_chx_source_adc_even  = '000000000001'
tx_chx_source_adc_odd   = '000000000010'

if vadc_select % 2 == 0:  
    MM_CONF.fields['tx_ch7_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX7 (VADC14, SEQREG)
    MM_CONF.fields['tx_ch6_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX6 (VADC12, SEQREG)
    MM_CONF.fields['tx_ch5_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX5 (VADC10, SEQREG)
    MM_CONF.fields['tx_ch4_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX4 (VADC8, SEQREG)
    MM_CONF.fields['tx_ch3_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX3 (VADC6, SEQREG)
    MM_CONF.fields['tx_ch2_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX2 (VADC4, SEQREG)
    MM_CONF.fields['tx_ch1_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX1 (VADC2, SEQREG)
    MM_CONF.fields['tx_ch0_source'].set_value(int(tx_chx_source_adc_even,2))    #Data souces for TX0 (VADC0, SEQREG)
elif vadc_select % 2 == 1:
    MM_CONF.fields['tx_ch7_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX7 (VADC15, SEQREG)
    MM_CONF.fields['tx_ch6_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX6 (VADC13, SEQREG)
    MM_CONF.fields['tx_ch5_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX5 (VADC11, SEQREG)
    MM_CONF.fields['tx_ch4_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX4 (VADC9, SEQREG)
    MM_CONF.fields['tx_ch3_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX3 (VADC7, SEQREG)
    MM_CONF.fields['tx_ch2_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX2 (VADC5, SEQREG)
    MM_CONF.fields['tx_ch1_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX1 (VADC3, SEQREG)
    MM_CONF.fields['tx_ch0_source'].set_value(int(tx_chx_source_adc_odd,2))     #Data souces for TX0 (VADC1, SEQREG)    


# ------------------- ADC calibration -------------------
MM_CONF.fields['adc_cal_first_stage'].set_value(6)      # First stage = 6 (ADC stage 6)
MM_CONF.fields['adc_cal_first_adc'].set_value(0)       # First ADC = 0 (VADC0)
MM_CONF.fields['adc_cal_last_stage'].set_value(1)       # Last stage = 1 (ADC stage 1)
MM_CONF.fields['adc_cal_last_adc'].set_value(15)        # Last ADC = 15 (VADC15)
MM_CONF.fields['adc_cal_avgbits'].set_value(15)         # Average number of bits
    
# ------------------- OUTMUX -------------------
MM_CONF.fields['outmux_sel0'].set_value(13)             # Set up DOUT0 to output acquire
MM_CONF.fields['outmux_sel1'].set_value(16)             # Set up DOUT1 to output DOR(1), used for trigger ACQ-start

# ------------------- RAM config -------------------
MM_CONF.fields[ 'imem_enable_direct_mode' ].set_value(0)
MM_CONF.fields[ 'imem_enable_acorr' ].set_value(1)
MM_CONF.fields[ 'imem_enable_corr1' ].set_value(1)


for regaddr, reg in MMRST.copy().registers.items():
    if reg.value != MM_CONF.registers[regaddr].value:
        print(regaddr, MM_CONF.registers[regaddr].value)
        tcp.writeAsicSpiRegister(regaddr, 1, 8, MM_CONF.registers[regaddr].value)
        data = tcp.getSystemReadBack(200)
        print(data)
        # time.sleep(0.1)

#for regardd, reg in MMRST.copy().registers.items():
#        print(help(MM_CONF.registers[regaddr])) #.fieldpos_list, MM_CONF.registers[regaddr].fieldval_list)
